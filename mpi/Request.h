//
// Created by User on 03.07.2019.
//

#ifndef MPI2_REQUEST_H
#define MPI2_REQUEST_H

#include <stdexcept>
#include <iostream>
#include <vector>

#include "mpi.h"
#include "exceptions.h"

namespace mpi {


    /**
     * Represents a single request. An instance of this class is usually generated by using some non-blocking process
     * something like this:
     * Request req = comm.some_nonblocking_process(...)
     *
     * The non-blocking process just starts the data transmission. To tell MPI to finish the transmission call:
     * req.wait()
     * The wait() method may suspend execution of your application unti the data transmission has been finished.
     */
    class Request {
    private:
        MPI_Request content;
        bool canceled = false;

    public:
        Request(): Request(MPI_REQUEST_NULL) {};

        Request(MPI_Request req){
            content = req;
            canceled = true;
        };


        Request(const Request& o) = delete;

        Request(Request&& o){
            content = o.content;
            canceled = o.canceled;
            o.content = MPI_REQUEST_NULL;
            o.canceled = false;
        }


        Request& operator=(const Request& req) = delete;


        /**
         * assigns the result of isend, irecv operation to the request
         *
         * @param req - the output of the functions mentioned above
         * @return the request object
         */
        Request& operator=(const MPI_Request& req){
            content = req;
            canceled = false;
            return *this;
        }

        ~Request() {
            int errcode;
            if (content != MPI_REQUEST_NULL) {
                if ((errcode = MPI_Request_free(&content)) != MPI_SUCCESS) {
                    switch (errcode) {
                        case MPI_ERR_REQUEST:
                            std::cerr << "Error in request free: incorrect request\n";
                            break;
                        case MPI_ERR_ARG:
                            std::cerr << "Error in request free: incorrect argument\n";
                            break;
                        default:
                            std::cerr << "Error in request free: unknown error\n";
                    }
                }
            }
        }

        /**
         * Starts the execution of send request
         *
         */
        void start(){
            if (content == MPI_REQUEST_NULL) return;
            int errcode;
            if ((errcode = MPI_Start(&content)) != MPI_SUCCESS){
                throw_exception(errcode);
            }
        }


        /**
         * Waits until the request completed
         *
         * @param status - the information about the data received
         */
        void wait(MPI_Status* status = MPI_STATUS_IGNORE){
            if (content == MPI_REQUEST_NULL){
                return;
            };
            int errcode;
            if ((errcode = MPI_Wait(&content, status)) != MPI_SUCCESS){
                throw_exception(errcode);
            }
        }


        /**
         * Tests for the request completion
         *
         * @param status - pointer to the structure where the status of the completed request
         * will be written (optional)
         * @return true if request has been completed, false otherwise
         */
        bool test(MPI_Status* status = MPI_STATUS_IGNORE){
            int flag;
            int errcode;
            if ((errcode = MPI_Test(&content, &flag, status)) != MPI_SUCCESS){
                throw_exception(errcode);
            }
            return flag != 0;
        }

        /**
         * Cancels the request execution
         *
         */
        void cancel(){
            int errcode;
            if ((errcode = MPI_Cancel(&content)) != MPI_SUCCESS){
                throw_exception(errcode);
            }
            canceled = true;
        }

        /**
         * Tests if the request has cancelled
         *
         * @return true if the request was canceled, false otherwise
         */
        bool isCanceled() { return canceled; }

        operator MPI_Request(){
            return content;
        }
    };


    /**
     * A container for a list of requests. The requests are some data which you receive as  result of
     * any nonblocking routines. These routines just start the data transmission process and gives you information
     * about this process as a function result. Such results shall be put into this container in the following way:
     *
     * Reqyests requests(N); // N is max. number of requests
     * requests = comm.some_nonblocking_routine(); // The overloaded operator = inplies to put the request into
     * the container
     * requests = comm.some_nonblocking_routine();
     * .....
     * requests.waitAll(); // You tell all non-blocking routines to complete. This function may suspend the
     * execution of your application by the time necessary for the comoletion of requests
     */
    class Requests{
    private:
        MPI_Request* content;
        int number;
        int current_number;
    public:

        /**
         * Initializes the request list
         *
         * @param n - estimated number of the requests. The actual number may not conincide with the estimated
         * one but shall not be greater
         */
        Requests(int n): number(n) {
            content = new MPI_Request[n];
            current_number = 0;
        };
        Requests(const Requests& req) = delete;

        /**
         * Allows requests = f(...) assignments
         *
         * @param other - the right-handed side
         */
        Requests(Requests&& other){
            content = other.content;
            other.content = nullptr;
            number = other.number;
            other.number = 0;
            current_number = other.current_number;
            other.current_number = 0;
        }

        /**
         * Returns a pointer to the request list
         *
         * @return a pointer to the request list
         */
        operator MPI_Request*(){
            return &content[0];
        }

        ~Requests(){
            for (int i = 0; i < current_number; i++){
                int errcode;
                if (content[i] == MPI_REQUEST_NULL){
                    continue;
                }
                if ((errcode = MPI_Request_free(content+i)) != MPI_SUCCESS){
                    switch (errcode) {
                        case MPI_ERR_REQUEST:
                            std::cerr << "Error in request free: incorrect request\n";
                            break;
                        case MPI_ERR_ARG:
                            std::cerr << "Error in request free: incorrect argument\n";
                            break;
                        default:
                            std::cerr << "Error in request free: unknown error\n";
                    }
                }
            }
            delete [] content;
        }

        /**
         * Starts all send requests
         *
         */
        void start(){
            int errcode;
            if ((errcode = MPI_Startall(number, content)) != MPI_SUCCESS){
                throw_exception(errcode);
            }
        }

        /**
         * Adds the request to the request list
         *
         * @param request - the result of Communicator::isend or Communicator::irecv function execution
         * @return *this
         */
        Requests& operator=(const MPI_Request& request){
            content[current_number] = request;
            current_number++;
            return *this;
        }

        /**
         * Computes the total number of all requests added
         *
         * @return total number of requests added
         */
        int getRequestNumber() { return current_number; }

        /**
         * Suspends the execution of the program until all requests completed.
         * Forces to complete all requests
         *
         * @param statuses - array of statuses. Status of each request will be filled into such array
         * (optional)
         */
        void waitAll(MPI_Status statuses[] = MPI_STATUSES_IGNORE){
            int errcode;
            if ((errcode = MPI_Waitall(current_number, content, statuses)) != MPI_SUCCESS){
                throw_exception(errcode);
            }
        }

        /**
         * Tests for completion of all requests in the list
         *
         * @param statuses - array of statuses of all completed requests
         * The array will be filled during the routine execution (optional)
         * @return true if all requests were completed
         */
        bool testAll(MPI_Status statuses[] = MPI_STATUSES_IGNORE){
            int flag;
            int errcode;
            if ((errcode = MPI_Testall(current_number, content, &flag, statuses)) != MPI_SUCCESS){
                throw_exception(errcode);
            }
            return flag != 0;
        }

        /**
         * Tests for completion of any requests in the list
         *
         * @param status - pointer to the status object where request info will be written
         * (optional)
         * @return index of the completed request or MPI_UNDEFINED if no requests were completed
         */
        int testAny(MPI_Status* status = MPI_STATUS_IGNORE){
            int flag;
            int index;
            int errcode;
            if ((errcode = MPI_Testany(current_number, content, &index, &flag, status) != MPI_SUCCESS)){
                throw_exception(errcode);
            }
            if (flag){
                return index;
            } else {
                return MPI_UNDEFINED;
            }
        }

        /**
         * Waits until any of the requests in the list completed
         *
         * @param status - pointer to the status of the completed requests (optional)
         * @return - index of the completed request
         */
        int waitAny(MPI_Status* status = MPI_STATUS_IGNORE){
            int errcode;
            int request_index;
            if ((errcode = MPI_Waitany(current_number, content, &request_index, status)) != MPI_SUCCESS){
                throw_exception(errcode);
            }
            return request_index;
        }

        /**
         * Deletes a certain requests from the array
         *
         * @param index - index of the request deleted
         */
        void deleteRequest(int index){
            if (content[index] != MPI_REQUEST_NULL){
                Request req(content[index]);
            }
            for (int i = index + 1; i < current_number; i++){
                content[i-1] = content[i];
            }
        }
    };

}

#endif //MPI2_REQUEST_H
